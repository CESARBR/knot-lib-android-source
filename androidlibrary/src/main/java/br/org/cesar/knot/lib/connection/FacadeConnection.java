/*
 * Copyright (c) 2017, CESAR.
 * All rights reserved.
 *
 * This software may be modified and distributed under the terms
 * of the BSD license. See the LICENSE file for details.
 *
 *
 */
package br.org.cesar.knot.lib.connection;

import android.support.annotation.NonNull;

import com.google.gson.JsonElement;

import java.util.List;

import br.org.cesar.knot.lib.event.Event;
import br.org.cesar.knot.lib.exception.KnotException;
import br.org.cesar.knot.lib.exception.SocketNotConnected;
import br.org.cesar.knot.lib.model.AbstractThingData;
import br.org.cesar.knot.lib.model.AbstractThingDevice;
import br.org.cesar.knot.lib.model.AbstractThingMessage;
import br.org.cesar.knot.lib.model.ThingList;

/**
 * The type Facade connection.
 */
public class FacadeConnection {


    private static final Object lock = new Object();
    private static FacadeConnection sInstance;

    private KnotSocketIo socketIO;
    private ThingApi thingApi;

    private FacadeConnection() {
    }

    /**
     * Gets instance.
     *
     * @return the instance
     */
    public static FacadeConnection getInstance() {
        synchronized (lock) {
            if (sInstance == null) {
                sInstance = new FacadeConnection();
            }
            return sInstance;
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    // SocketIO
    ///////////////////////////////////////////////////////////////////////////

    /**
     * Sets socket io.
     *
     * @param baseUrl the base url
     * @throws SocketNotConnected the socket not connected
     */
    public synchronized void setupSocketIO(@NonNull String baseUrl) throws SocketNotConnected {
        socketIO = new KnotSocketIo(baseUrl);
    }

    /**
     * Socket io create new device on meshblu
     *
     * @param <T>            the type parameter
     * @param device         the device
     * @param callbackResult the callback result
     * @throws SocketNotConnected the socket not connected
     */
    public synchronized <T extends AbstractThingDevice> void socketIOCreateNewDevice(final T device, final Event<T> callbackResult) throws SocketNotConnected {
        if (socketIO != null && !isSocketConnected()) {
            socketIO.createNewDevice(device, callbackResult);
        } else {
            throw new SocketNotConnected("Socket not connected");
        }
    }

    /**
     * Is socket connected boolean.
     *
     * @return the boolean
     */
    public boolean isSocketConnected() {
        if (socketIO != null) {
            return socketIO.isSocketConnected();
        } else {
            return false;
        }
    }


    /**
     * Open a new socket with the meshblus
     *
     * @param endPoint endpoint of gateway
     * @throws SocketNotConnected if its not possible to open a socket
     */
    public void connectSocket(@NonNull String endPoint) throws SocketNotConnected {
        disconnectSocket();
        if (socketIO == null) {
            setupSocketIO(endPoint);
            socketIO.connect(endPoint);
        }
    }

    /**
     * Disconnect and invalidate the current socket. You must call {@link #connectSocket(String)} to open a valid socket
     * before to do any action on meshblu
     */
    public void disconnectSocket() {
        if (isSocketConnected()) {
            socketIO.disconnect();
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    // Http
    ///////////////////////////////////////////////////////////////////////////

    /**
     * Setup the http api
     *
     * @param endPoint the end point
     */
    public void setupHttp(@NonNull String endPoint) {
        thingApi = new ThingApi(endPoint);
    }

    /**
     * Generate a new Device in Meshblu instance
     *
     * @param device model sample to create a new one. Basically this device model
     *               contains attributes that will be saved into Meshblu.
     *               Please note that uuid and token will always
     *               be generated by Meshblu (please see AbstractThingDevice).
     *               It is important set the custom attribute for your classes
     * @return New device with meshblu token and uuid values
     * @throws KnotException
     * @see AbstractThingDevice
     */
    public <T extends AbstractThingDevice> T httpCreateDevice(T device) throws KnotException, IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            return thingApi.createDevice(device);
        }
    }

    /**
     * Async version of {@link #httpCreateDevice(AbstractThingDevice)}
     *
     * @param device   model sample to create a new one. Basically this device model
     *                 contains attributes that will be saved into Meshblu.
     *                 Please note that uuid and token will always
     *                 be generated by Meshblu (please see AbstractThingDevice).
     *                 It is important set the custom attribute for your classes
     * @param callback Callback for this method
     * @see AbstractThingDevice
     */
    public <T extends AbstractThingDevice> void httpCreateDevice(final T device, final ThingApi.Callback<T> callback) throws IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            thingApi.createDevice(device, callback);
        }
    }

    /**
     * Turns the device belongs to someone. When a device is created in
     * Meshblu, it is an orphan device. In other words, everyone can made any
     * changes on this device. After claim a device, only the
     * owner can delete or update it.
     * Note: In Meshblu, the owner for one device IS another device.
     *
     * @param owner  the identifier of owner to connect on Meshblu (uuid).
     * @param token  the token for owner
     * @param device the identifier of device (uuid)
     * @return a boolean value to indicate if the device could be claimed
     * @throws KnotException
     */
    public Boolean httpClaimDevice(String owner, String token, String device) throws KnotException, IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            return thingApi.claimDevice(owner, token, device);
        }
    }

    /**
     * Async version of {@link #httpClaimDevice(String, String, String)}
     *
     * @param owner    the identifier of owner to connect on Meshblu (uuid).
     * @param token    the token for owner
     * @param device   the identifier of device (uuid)
     * @param callback Callback for this method
     */
    public void httpClaimDevice(final String owner, final String token, final String device, final ThingApi.Callback<Boolean> callback) throws IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            thingApi.claimDevice(owner, token, device, callback);
        }
    }

    /**
     * Update an existent device
     *
     * @param owner  the identifier of owner to connect on Meshblu (uuid).
     * @param token  the token for owner
     * @param device the identifier of device (uuid)
     * @return the object updated
     * @throws KnotException
     */
    public <T extends AbstractThingDevice> T httpUpdateDevice(String owner, String token, String id, T device) throws KnotException, IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            return thingApi.updateDevice(owner, token, id, device);
        }
    }

    /**
     * Async version of {@link #httpUpdateDevice(String, String, String, AbstractThingDevice)}
     *
     * @param owner    the identifier of owner to connect on Meshblu (uuid).
     * @param token    the token for owner
     * @param device   the identifier of device (uuid)
     * @param callback Callback for this method
     */
    public <T extends AbstractThingDevice> void httpUpdateDevice(final String owner, final String token,
                                                                 final String id, final T device, final ThingApi.Callback<T> callback) throws IllegalStateException {

        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            thingApi.updateDevice(owner, token, id, device, callback);
        }
    }

    /**
     * Delete a device from Meshblu instance. If the device is an orphan one,
     * anyone can delete it. However if the device has an owner,
     * only it can execute this action.
     *
     * @param owner  the owner of the device.
     * @param token  the token for this owner
     * @param device the device identifier (uuid)
     * @return a boolean to indicate if the device was deleted
     * @throws KnotException
     */
    public boolean httpDdeleteDevice(String owner, String token, String device) throws KnotException, IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            return thingApi.deleteDevice(owner, token, device);
        }
    }

    /**
     * Async version of {@link ThingApi#deleteDevice(String, String, String)}
     *
     * @param owner    the owner of the device.
     * @param token    the token for this owner
     * @param device   the device identifier (uuid)
     * @param callback Callback for this method
     */
    public void httpDeleteDevice(final String owner, final String token, final String device, final ThingApi.Callback<Boolean> callback) throws IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            thingApi.deleteDevice(owner, token, device, callback);
        }
    }

    /**
     * Get all information regarding the device.
     *
     * @param owner the owner of the device.
     * @param token the token for this owner
     * @param clazz The class for this device. Meshblu works with any type of objects and
     *              it is necessary deserialize the return to a valid object.
     *              Note: The class parameter should be a extension of {@link AbstractThingDevice}
     * @return an json element containing device informations
     * @throws KnotException
     */
    public <T extends JsonElement> T httpWhoAmI(String owner, String token, Class<T> clazz) throws KnotException, IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            return thingApi.whoAmI(owner, token, clazz);
        }
    }

    /**
     * Async version of {@link #httpWhoAmI(String, String, Class)}
     *
     * @param owner    the owner of the device.
     * @param token    the token for this owner
     * @param clazz    The class for this device. Meshblu works with any type of objects and
     *                 it is necessary deserialize the return to a valid object.
     *                 Note: The class parameter should be a extension of {@link AbstractThingDevice}
     * @param callback Callback for this method
     * @return an object based on the class parameter
     */

    public <T extends JsonElement> void httpWhoAmI(final String owner, final String token,
                                               final Class<T> clazz, final ThingApi.Callback<T> callback) throws IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            thingApi.whoAmI(owner, token, clazz, callback);
        }
    }

    /**
     * Get a specific device from Meshblu instance.
     *
     * @param owner  the owner of the device.
     * @param token  the token for this owner
     * @param device the device identifier (uuid)
     * @param clazz  The class for this device. Meshblu works with any type of objects and
     *               it is necessary deserialize the return to a valid object.
     *               Note: The class parameter should be a extension of {@link AbstractThingDevice}
     * @return an object based on the class parameter
     * @throws KnotException
     */
    public <T extends AbstractThingDevice> T httpGetDevice(String owner, String token, String device, Class<T> clazz) throws KnotException, IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            return thingApi.getDevice(owner, token, device, clazz);
        }
    }

    /**
     * Async version of {@link #getDevice(String, String, String, Class)}
     *
     * @param owner    the owner of the device.
     * @param token    the token for this owner
     * @param device   the device identifier (uuid)
     * @param clazz    The class for this device. Meshblu works with any type of objects and
     *                 it is necessary deserialize the return to a valid object.
     *                 Note: The class parameter should be a extension of {@link AbstractThingDevice}
     * @param callback Callback for this method
     * @return an object based on the class parameter
     */
    public <T extends AbstractThingDevice> void httpGetDevice(final String owner, final String token,
                                                          final String device, final Class<T> clazz, final ThingApi.Callback<T> callback) throws IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            thingApi.getDevice(owner, token, device, clazz, callback);
        }
    }

    /**
     * Get a specific device's gateway from Meshblu instance.
     *
     * @param owner  the owner of the device.
     * @param token  the token for this owner
     * @param device the device identifier (uuid)
     * @param clazz  The class for this device. Meshblu works with any type of objects and
     *               it is necessary deserialize the return to a valid object.
     *               Note: The class parameter should be a extension of {@link AbstractThingDevice}
     * @return an object based on the class parameter
     * @throws KnotException
     */
    public <T extends AbstractThingDevice> T httpGetDeviceGateway(String owner, String token, String device, Class<T> clazz) throws KnotException, IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            return thingApi.getDeviceGateway(owner, token, device, clazz);
        }
    }

    /**
     * Async version of {@link #getDeviceGateway(String, String, String, Class)}
     *
     * @param owner    the owner of the device.
     * @param token    the token for this owner
     * @param device   the device identifier (uuid)
     * @param clazz    The class for this device. Meshblu works with any type of objects and
     *                 it is necessary deserialize the return to a valid object.
     *                 Note: The class parameter should be a extension of {@link AbstractThingDevice}
     * @param callback Callback for this method
     * @return an object based on the class parameter
     */
    public <T extends AbstractThingDevice> void httpGetDeviceGateway(final String owner, final String token,
                                                                 final String device, final Class<T> clazz, final ThingApi.Callback<T> callback) throws IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            thingApi.getDeviceGateway(owner, token, device, clazz, callback);
        }
    }

    /**
     * Get all devices those are claimed by one owner
     *
     * @param owner the owner of the device.
     * @param token the token for this owner
     * @param type  object that will define what elements will returned by this method
     * @return a List with all devices those belongs to the owner
     * @throws KnotException
     */
    public <T extends AbstractThingDevice> List<T> httpGetDeviceList(String owner, String token, final ThingList<T> type) throws KnotException, IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            return thingApi.getDeviceList(owner, token, type);
        }
    }

    /**
     * Async version of {@link #getDeviceList(String, String, ThingList)}
     *
     * @param owner    the owner of the device.
     * @param token    the token for this owner.
     * @param type     object that will define what elements will returned by this method
     * @param callback
     * @return a List with all devices those belongs to the owner
     * @throws KnotException
     */
    public <T extends AbstractThingDevice> void httpGetDeviceList(final String owner, final String token, final ThingList<T> type, final ThingApi.Callback<List<T>> callback) throws IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            thingApi.getDeviceList(owner, token, type, callback);
        }
    }

    /**
     * Create data for one device. If the device has an owner, it is necessary that the owner
     * param be the same of the device owner.
     *
     * @param owner  the owner of the device.
     * @param token  the token for this owner.
     * @param device the device identifier (uuid)
     * @param data   data that will be created for device
     * @return a boolean value to indicate if the data could be create for device
     * @throws KnotException
     */
    public <T extends AbstractThingData> boolean httpCreateData(String owner, String token, String device, T data) throws KnotException, IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            return thingApi.createData(owner, token, device, data);
        }
    }

    /**
     * Async version of {@link #createData(String, String, String, AbstractThingData)}
     *
     * @param owner    the owner of the device.
     * @param token    the token for this owner.
     * @param device   the device identifier (uuid)
     * @param data     data that will be created for device
     * @param callback Callback for this method
     * @return a boolean value to indicate if the data could be create for device
     * @throws KnotException
     */
    public <T extends AbstractThingData> void httpCreateData(final String owner, final String token,
                                                         final String device, final T data, final ThingApi.Callback<Boolean> callback) throws IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            thingApi.createData(owner, token, device, data, callback);
        }
    }

    /**
     * @param owner  the owner of the device.
     * @param token  the token for this owner.
     * @param device the device identifier (uuid)
     * @param type   object that will define what elements will returned by this method
     * @return a List with data of the device
     * @throws KnotException
     */
    public <T extends AbstractThingData> List<T> httpGetDataList(String owner, String token, String device, final ThingList<T> type) throws KnotException, IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            return thingApi.getDataList(owner, token, device, type);
        }
    }

    /**
     * Async version of {@link #httpGetDataList(String, String, String, ThingList)}
     *
     * @param owner    the owner of the device.
     * @param token    the token for this owner.
     * @param device   the device identifier (uuid)
     * @param type     object that will define what elements will returned by this method
     * @param callback Callback for this method
     * @return a List with data of the device
     */
    public <T extends AbstractThingData> void httpGetDataList(final String owner, final String token, final String device, final ThingList<T> type, final ThingApi.Callback<List<T>> callback) throws IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            thingApi.getDataList(owner, token, device, type, callback);
        }
    }

    /**
     * Send a message in Meshblu instance
     *
     * @param message model sample to create a new message. Basically this message model
     *                contains attributes that will be send into Meshblu.
     * @return New message with meshblu content.
     * @throws KnotException
     * @see AbstractThingMessage
     */
    public <T extends AbstractThingMessage> T httpSendMessage(String owner, String token, T message) throws KnotException, IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            return thingApi.sendMessage(owner, token, message);
        }
    }

    /**
     * Send a message in Meshblu instance
     *
     * @param message model sample to create a new message. Basically this message model
     *                contains attributes that will be send into Meshblu.
     * @return New message with meshblu content.
     * @see AbstractThingMessage
     */
    public <T extends AbstractThingMessage> void httpSendMessage(final String owner, final String token, final T message, final ThingApi.Callback<T> callback) throws IllegalStateException {
        if (thingApi == null) {
            throw new IllegalStateException("was you call the setupHttp?");
        } else {
            thingApi.sendMessage(owner, token, message, callback);
        }
    }

}