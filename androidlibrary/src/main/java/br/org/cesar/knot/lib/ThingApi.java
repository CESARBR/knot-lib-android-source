/*
 * Copyright (c) 2016, CESAR.
 * All rights reserved.
 *
 * This software may be modified and distributed under the terms
 * of the BSD license. See the LICENSE file for details.
 *
 */
package br.org.cesar.knot.lib;

import android.os.Handler;
import android.os.Looper;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonParser;
import com.squareup.okhttp.MediaType;
import com.squareup.okhttp.OkHttpClient;
import com.squareup.okhttp.Request;
import com.squareup.okhttp.RequestBody;
import com.squareup.okhttp.Response;

import java.net.HttpURLConnection;
import java.util.List;

import br.org.cesar.knot.lib.model.AbstractThingData;
import br.org.cesar.knot.lib.model.AbstractThingDevice;
import br.org.cesar.knot.lib.model.AbstractThingMessage;

/**
 * The main class that list all method available to use with KNOT
 */
public class ThingApi {

    private static final String EMPTY_JSON = "{}";
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
    private static final String HEADER_AUTH_UUID = "meshblu_auth_uuid";
    private static final String HEADER_AUTH_TOKEN = "meshblu_auth_token";
    private static final String DATA_PATH = "/data/";
    private static final String DEVICE_PATH = "/devices/";
    private static final String DEVICE_PROPERTY_PATH_GATEWAY = "/gateway/";
    private static final String CLAIM_DEVICES_PATH = "/claimdevice/";
    private static final String WHOAMI = "/v2/whoami/";
    private static final String MY_DEVICES_PATH = "/mydevices/";
    private static final String MESSAGE = "/messages/";
    public static final String EMPTY_ARRAY = "[]";
    private static ThingApi sInstance;
    private final Handler mMainHandler;
    private final OkHttpClient mHttpClient;
    private final Gson mGson;
    private final String mEndPoint;

    private ThingApi(String endPoint) {
        mMainHandler = new Handler(Looper.getMainLooper());
        mHttpClient = new OkHttpClient();
        mGson = new Gson();
        mEndPoint = endPoint;
    }

    /**
     * Return a instance of api
     * @param endPoint
     * @return
     */
    public static ThingApi getInstance(String endPoint) {
        if (sInstance == null) {
            sInstance = new ThingApi(endPoint);
        }
        return sInstance;
    }

    // Device methods

    /**
     * Generate a new Device in Meshblu instance
     * @param device model sample to create a new one. Basically this device model
     *               contains attributes that will be saved into Meshblu.
     *               Please note that uuid and token will always
     *               be generated by Meshblu (please see AbstractThingDevice).
     *               It is important set the custom attribute for your classes
     *
     * @return New device with meshblu token and uuid values
     *
     * @see AbstractThingDevice
     *
     * @throws KnotException
     * */
    public <T extends AbstractThingDevice> T createDevice(T device) throws KnotException {
        final String endPoint = mEndPoint + DEVICE_PATH;
        String json = mGson.toJson(device);
        RequestBody body = createRequestBodyWith(json);
        Request request = generateBasicRequestBuild(endPoint).post(body).build();

        try {
            Response response = mHttpClient.newCall(request).execute();
            return (T) mGson.fromJson(response.body().string(), device.getClass());
        } catch (Exception e) {
            throw new KnotException(e);
        }
    }

    /**
     * Async version of {@link #createDevice(AbstractThingDevice)}
     * @param device model sample to create a new one. Basically this device model
     *               contains attributes that will be saved into Meshblu.
     *               Please note that uuid and token will always
     *               be generated by Meshblu (please see AbstractThingDevice).
     *               It is important set the custom attribute for your classes
     *
     * @param callback Callback for this method
     *
     * @see AbstractThingDevice
     * */
    public <T extends AbstractThingDevice> void createDevice(final T device, final Callback<T> callback) {
        new Thread() {
            @Override
            public void run() {
                try {
                    T result = createDevice(device);
                    dispatchSuccess(callback, result);
                } catch (final KnotException e) {
                    dispatchError(callback, e);
                }
            }
        }.start();
    }

    /**
     * Turns the device belongs to someone. When a device is created in
     * Meshblu, it is an orphan device. In other words, everyone can made any
     * changes on this device. After claim a device, only the
     * owner can delete or update it.
     * Note: In Meshblu, the owner for one device IS another device.

     * @param owner the identifier of owner to connect on Meshblu (uuid).
     * @param token the token for owner
     * @param device the identifier of device (uuid)
     *
     * @return a boolean value to indicate if the device could be claimed
     *
     * @throws KnotException
     * */
    public Boolean claimDevice(String owner, String token, String device) throws KnotException {
        final String endPoint = mEndPoint + CLAIM_DEVICES_PATH + device;
        RequestBody body = createEmptyRequestBody();
        Request request = generateBasicRequestBuild(owner, token, endPoint).put(body).build();

        try {
            Response response = mHttpClient.newCall(request).execute();
            return response.code() == HttpURLConnection.HTTP_OK;
        } catch (Exception e) {
            throw new KnotException(e);
        }
    }

    /**
     * Async version of {@link #claimDevice(String, String, String)}
     * @param owner the identifier of owner to connect on Meshblu (uuid).
     * @param token the token for owner
     * @param device the identifier of device (uuid)
     * @param callback Callback for this method
     * */
    public void claimDevice(final String owner, final String token, final String device, final Callback<Boolean> callback) {
        new Thread() {
            @Override
            public void run() {
                try {
                    Boolean result = claimDevice(owner, token, device);
                    dispatchSuccess(callback, result);
                } catch (final KnotException e) {
                    dispatchError(callback, e);
                }
            }
        }.start();
    }

    /**
     * Update an existent device
     * @param owner the identifier of owner to connect on Meshblu (uuid).
     * @param token the token for owner
     * @param device the identifier of device (uuid)
     *
     * @return the object updated
     *
     * @throws KnotException
     * */
    public <T extends AbstractThingDevice> T updateDevice(String owner, String token, String id, T device) throws KnotException {
        final String endPoint = mEndPoint + DEVICE_PATH + id;
        String json = mGson.toJson(device);
        RequestBody body = createRequestBodyWith(json);
        Request request = generateBasicRequestBuild(owner, token, endPoint).put(body).build();

        try {
            Response response = mHttpClient.newCall(request).execute();
            return (T) mGson.fromJson(response.body().string(), device.getClass());
        } catch (Exception e) {
            throw new KnotException(e);
        }
    }

    /**
     * Async version of {@link #updateDevice(String, String, String, AbstractThingDevice)}
     * @param owner the identifier of owner to connect on Meshblu (uuid).
     * @param token the token for owner
     * @param device the identifier of device (uuid)
     * @param callback Callback for this method
     * */
    public <T extends AbstractThingDevice> void updateDevice(final String owner, final String token,
                                                             final String id, final T device, final Callback<T> callback) {
        new Thread() {
            @Override
            public void run() {
                try {
                    T result = updateDevice(owner, token, id, device);
                    dispatchSuccess(callback, result);
                } catch (KnotException e) {
                    dispatchError(callback, e);
                }
            }
        }.start();
    }

    /**
     * Delete a device from Meshblu instance. If the device is an orphan one,
     * anyone can delete it. However if the device has an owner,
     * only it can execute this action.
     *
     * @param owner the owner of the device.
     * @param token the token for this owner
     * @param device the device identifier (uuid)
     *
     * @return a boolean to indicate if the device was deleted
     *
     * @throws KnotException
     * */
    public boolean deleteDevice(String owner, String token, String device) throws KnotException {
        final String endPoint = mEndPoint + DEVICE_PATH + device;
        Request request = generateBasicRequestBuild(owner, token, endPoint).delete().build();

        try {
            Response response = mHttpClient.newCall(request).execute();
            return response.code() == HttpURLConnection.HTTP_OK;
        } catch (Exception e) {
            throw new KnotException(e);
        }
    }

    /**
     * Async version of {@link ThingApi#deleteDevice(String, String, String)}
     * @param owner the owner of the device.
     * @param token the token for this owner
     * @param device the device identifier (uuid)
     * @param callback Callback for this method
     * */
    public void deleteDevice(final String owner, final String token, final String device, final Callback<Boolean> callback) {
        new Thread() {
            @Override
            public void run() {
                try {
                    Boolean result = deleteDevice(owner, token, device);
                    dispatchSuccess(callback, result);
                } catch (KnotException e) {
                    dispatchError(callback, e);
                }
            }
        }.start();
    }

    /**
     * Get all information regarding the device.
     * @param owner the owner of the device.
     * @param token the token for this owner
     * @param clazz The class for this device. Meshblu works with any type of objects and
     *              it is necessary deserialize the return to a valid object.
     *              Note: The class parameter should be a extension of {@link AbstractThingDevice}
     *
     * @return an json element containing device informations
     *
     * @throws KnotException
     */
    public <T extends JsonElement> T whoAmI(String owner, String token, Class<T> clazz) throws KnotException {
        final String endPoint = mEndPoint + WHOAMI;
        Request request = generateBasicRequestBuild(owner, token, endPoint).build();

        try {
            Response response = mHttpClient.newCall(request).execute();
            JsonElement jsonElement = new JsonParser().parse(response.body().string());
            return mGson.fromJson(jsonElement.toString(), clazz);
        } catch (Exception e) {
            throw new KnotException(e);
        }
    }

    /**
     * Async version of {@link #whoAmI(String, String, Class)}
     * @param owner the owner of the device.
     * @param token the token for this owner
     * @param clazz The class for this device. Meshblu works with any type of objects and
     *              it is necessary deserialize the return to a valid object.
     *              Note: The class parameter should be a extension of {@link AbstractThingDevice}
     *
     * @param callback Callback for this method
     *
     * @return an object based on the class parameter
     */

    public <T extends JsonElement> void whoAmI(final String owner, final String token,
                                                           final Class<T> clazz, final Callback<T> callback) {
        new Thread() {
            @Override
            public void run() {
                try {
                    T result = whoAmI(owner, token, clazz);
                    dispatchSuccess(callback, result);
                } catch (KnotException e) {
                    dispatchError(callback, e);
                }
            }
        }.start();
    }

    /**
     * Get a specific device from Meshblu instance.
     * @param owner the owner of the device.
     * @param token the token for this owner
     * @param device the device identifier (uuid)
     * @param clazz The class for this device. Meshblu works with any type of objects and
     *              it is necessary deserialize the return to a valid object.
     *              Note: The class parameter should be a extension of {@link AbstractThingDevice}
     *
     * @return an object based on the class parameter
     *
     * @throws KnotException
     */
    public <T extends AbstractThingDevice> T getDevice(String owner, String token, String device, Class<T> clazz) throws KnotException {
        final String endPoint = mEndPoint + DEVICE_PATH + device;
        Request request = generateBasicRequestBuild(owner, token, endPoint).build();

        try {
            Response response = mHttpClient.newCall(request).execute();
            JsonElement jsonElement = new JsonParser().parse(response.body().string());
            JsonArray jsonArray = jsonElement.getAsJsonObject().getAsJsonArray("devices");
            if (jsonArray.size() == 0) {
                return null;
            }
            return mGson.fromJson(jsonArray.get(0).toString(), clazz);
        } catch (Exception e) {
            throw new KnotException(e);
        }
    }

    /**
     * Async version of {@link #getDevice(String, String, String, Class)}
     * @param owner the owner of the device.
     * @param token the token for this owner
     * @param device the device identifier (uuid)
     * @param clazz The class for this device. Meshblu works with any type of objects and
     *              it is necessary deserialize the return to a valid object.
     *              Note: The class parameter should be a extension of {@link AbstractThingDevice}
     *
     * @param callback Callback for this method
     *
     * @return an object based on the class parameter
     */
    public <T extends AbstractThingDevice> void getDevice(final String owner, final String token,
                                                          final String device, final Class<T> clazz, final Callback<T> callback) {
        new Thread() {
            @Override
            public void run() {
                try {
                    T result = getDevice(owner, token, device, clazz);
                    dispatchSuccess(callback, result);
                } catch (KnotException e) {
                    dispatchError(callback, e);
                }
            }
        }.start();
    }

    /**
     * Get a specific device's gateway from Meshblu instance.
     * @param owner the owner of the device.
     * @param token the token for this owner
     * @param device the device identifier (uuid)
     * @param clazz The class for this device. Meshblu works with any type of objects and
     *              it is necessary deserialize the return to a valid object.
     *              Note: The class parameter should be a extension of {@link AbstractThingDevice}
     *
     * @return an object based on the class parameter
     *
     * @throws KnotException
     */
    public <T extends AbstractThingDevice> T getDeviceGateway(String owner, String token, String device, Class<T> clazz) throws KnotException {
        final String endPoint = mEndPoint + DEVICE_PATH + device + DEVICE_PROPERTY_PATH_GATEWAY;
        Request request = generateBasicRequestBuild(owner, token, endPoint).build();

        try {
            Response response = mHttpClient.newCall(request).execute();
            JsonElement jsonElement = new JsonParser().parse(response.body().string());
            JsonArray jsonArray = jsonElement.getAsJsonObject().getAsJsonArray("devices");
            if (jsonArray.size() == 0) {
                return null;
            }
            return mGson.fromJson(jsonArray.get(0).toString(), clazz);
        } catch (Exception e) {
            throw new KnotException(e);
        }
    }

    /**
     * Async version of {@link #getDeviceGateway(String, String, String, Class)}
     * @param owner the owner of the device.
     * @param token the token for this owner
     * @param device the device identifier (uuid)
     * @param clazz The class for this device. Meshblu works with any type of objects and
     *              it is necessary deserialize the return to a valid object.
     *              Note: The class parameter should be a extension of {@link AbstractThingDevice}
     *
     * @param callback Callback for this method
     *
     * @return an object based on the class parameter
     */
    public <T extends AbstractThingDevice> void getDeviceGateway(final String owner, final String token,
                                                          final String device, final Class<T> clazz, final Callback<T> callback) {
        new Thread() {
            @Override
            public void run() {
                try {
                    T result = getDeviceGateway(owner, token, device, clazz);
                    dispatchSuccess(callback, result);
                } catch (KnotException e) {
                    dispatchError(callback, e);
                }
            }
        }.start();
    }

    /**
     * Get all devices those are claimed by one owner
     * @param owner the owner of the device.
     * @param token the token for this owner
     * @param type object that will define what elements will returned by this method
     *
     * @return a List with all devices those belongs to the owner
     *
     * @throws KnotException
     */
    public <T extends AbstractThingDevice> List<T> getDeviceList(String owner, String token, final ThingList<T> type) throws KnotException {
        final String endPoint = mEndPoint + MY_DEVICES_PATH;
        Request request = generateBasicRequestBuild(owner, token, endPoint).build();

        try {
            Response response = mHttpClient.newCall(request).execute();
            if (response.code() != HttpURLConnection.HTTP_OK) {
                return null;
            }
            JsonElement jsonElement = new JsonParser().parse(response.body().string());
            JsonArray jsonArray = jsonElement.getAsJsonObject().getAsJsonArray("devices");
            return mGson.fromJson(jsonArray.toString(), type);
        } catch (Exception e) {
            throw new KnotException(e);
        }
    }

    /**
     * Async version of {@link #getDeviceList(String, String, ThingList)}
     * @param owner the owner of the device.
     * @param token the token for this owner.
     * @param type object that will define what elements will returned by this method
     * @param callback
     *
     * @return a List with all devices those belongs to the owner
     *
     * @throws KnotException
     */
    public <T extends AbstractThingDevice> void getDeviceList(final String owner, final String token, final ThingList<T> type, final Callback<List<T>> callback) {
        new Thread() {
            @Override
            public void run() {
                try {
                    List<T> result = getDeviceList(owner, token, type);
                    dispatchSuccess(callback, result);
                } catch (KnotException e) {
                    dispatchError(callback, e);
                }
            }
        }.start();
    }

    // Data methods

    /**
     * Create data for one device. If the device has an owner, it is necessary that the owner
     * param be the same of the device owner.
     *
     * @param owner the owner of the device.
     * @param token the token for this owner.
     * @param device the device identifier (uuid)
     * @param data data that will be created for device
     *
     * @return a boolean value to indicate if the data could be create for device
     *
     * @throws KnotException
     */
    public <T extends AbstractThingData> boolean createData(String owner, String token, String device, T data) throws KnotException {

        final String endPoint = mEndPoint + DATA_PATH + device;
        String json = mGson.toJson(data);
        RequestBody body = createRequestBodyWith(json);
        Request request = generateBasicRequestBuild(owner, token, endPoint).post(body).build();

        try {
            Response response = mHttpClient.newCall(request).execute();
            return response.code() == HttpURLConnection.HTTP_CREATED;
        } catch (Exception e) {
            throw new KnotException(e);
        }
    }

    /**
     * Async version of {@link #createData(String, String, String, AbstractThingData)}
     *
     * @param owner the owner of the device.
     * @param token the token for this owner.
     * @param device the device identifier (uuid)
     * @param data data that will be created for device
     * @param callback Callback for this method
     *
     * @return a boolean value to indicate if the data could be create for device
     *
     * @throws KnotException
     */
    public <T extends AbstractThingData> void createData(final String owner, final String token,
                                                         final String device, final T data, final Callback<Boolean> callback) {
        new Thread() {
            @Override
            public void run() {
                try {
                    Boolean result = createData(owner, token, device, data);
                    dispatchSuccess(callback, result);
                } catch (KnotException e) {
                    dispatchError(callback, e);
                }
            }
        }.start();
    }

    /**
     *
     * @param owner the owner of the device.
     * @param token the token for this owner.
     * @param device the device identifier (uuid)
     * @param type object that will define what elements will returned by this method
     *
     * @return a List with data of the device
     *
     * @throws KnotException
     */
    public <T extends AbstractThingData> List<T> getDataList(String owner, String token, String device, final ThingList<T> type) throws KnotException {
        final String endPoint = mEndPoint + DATA_PATH + device;
        Request request = generateBasicRequestBuild(owner, token, endPoint).build();

        try {
            Response response = mHttpClient.newCall(request).execute();
            JsonElement jsonElement = new JsonParser().parse(response.body().string());
            JsonArray jsonArray = jsonElement.getAsJsonObject().getAsJsonArray("data");

            if (jsonArray == null || jsonArray.size() == 0) {
                return mGson.fromJson(EMPTY_ARRAY, type);
            }

            return mGson.fromJson(jsonArray.toString(), type);
        } catch (Exception e) {
            throw new KnotException(e);
        }
    }

    /**
     * Async version of {@link #getDataList(String, String, String, ThingList)}
     * @param owner the owner of the device.
     * @param token the token for this owner.
     * @param device the device identifier (uuid)
     * @param type object that will define what elements will returned by this method
     *
     * @param callback Callback for this method
     *
     * @return a List with data of the device
     */
    public <T extends AbstractThingData> void getDataList(final String owner, final String token, final String device, final ThingList<T> type, final Callback<List<T>> callback) {
        new Thread() {
            @Override
            public void run() {
                try {
                    List<T> result = getDataList(owner, token, device, type);

                    dispatchSuccess(callback, result);
                } catch (KnotException e) {
                    dispatchError(callback, e);
                }
            }
        }.start();
    }

    //Message
    /**
     * Send a message in Meshblu instance
     * @param message model sample to create a new message. Basically this message model
     *               contains attributes that will be send into Meshblu.
     *
     * @return New message with meshblu content.
     *
     * @see AbstractThingMessage
     *
     * @throws KnotException
     * */
    public <T extends AbstractThingMessage> T sendMessage(String owner, String token, T message) throws KnotException {
        final String endPoint = mEndPoint + MESSAGE;
        String json = mGson.toJson(message);

        RequestBody body = createRequestBodyWith(json);
        Request request = generateBasicRequestBuild(owner, token, endPoint).post(body).build();

        try {
            Response response = mHttpClient.newCall(request).execute();
            JsonElement jsonElement = new JsonParser().parse(response.body().string());

            return (T) mGson.fromJson(jsonElement.toString(), message.getClass());
        } catch (Exception e) {
            throw new KnotException(e);
        }
    }

    /**
     * Send a message in Meshblu instance
     * @param message model sample to create a new message. Basically this message model
     *               contains attributes that will be send into Meshblu.
     *
     * @return New message with meshblu content.
     *
     * @see AbstractThingMessage
     * */
    public <T extends AbstractThingMessage> void sendMessage(final String owner, final String token, final T message, final Callback<T> callback) {
        new Thread() {
            @Override
            public void run() {
                try {
                    T result = sendMessage(owner, token, message);
                    dispatchSuccess(callback, result);
                } catch (final KnotException e) {
                    dispatchError(callback, e);
                }
            }
        }.start();
    }

    private RequestBody createEmptyRequestBody() {
        return RequestBody.create(JSON, EMPTY_JSON);
    }

    private RequestBody createRequestBodyWith(String data) {
        return RequestBody.create(JSON, data);
    }

    private Request.Builder generateBasicRequestBuild(String uuid, String token, String endPoint) {
        return new Request.Builder()
                .addHeader(HEADER_AUTH_UUID, uuid)
                .addHeader(HEADER_AUTH_TOKEN, token)
                .url(endPoint);
    }

    private Request.Builder generateBasicRequestBuild(String endPoint) {
        return new Request.Builder().url(endPoint);
    }

    private <T> void dispatchSuccess(final Callback<T> callback, final T result) {
        mMainHandler.post(new Runnable() {
            @Override
            public void run() {
                callback.onSuccess(result);
            }
        });
    }

    private <T> void dispatchError(final Callback<T> callback, final Exception error) {
        mMainHandler.post(new Runnable() {
            @Override
            public void run() {
                callback.onError(error);
            }
        });
    }

    /**
     * Interface used in asynchronous methods of ThingApi
     */
    public interface Callback<T> {

        void onSuccess(T result);

        void onError(Exception error);
    }
}
